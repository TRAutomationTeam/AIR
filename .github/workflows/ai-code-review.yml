name: AI Code Review

on:
  push:
    paths:
      - 'TR_Sanity_TaxCaddy/**/*.xaml'
  pull_request:
    paths:
      - 'TR_Sanity_TaxCaddy/**/*.xaml'
  workflow_dispatch:

jobs:
  review:
    runs-on: windows-latest
    
    steps:
    - uses: actions/checkout@v3
      
    - name: Check and Setup CUDA
      run: |
        Write-Host "Checking CUDA installation..."
        
        # Check if CUDA is already installed
        $cudaPath = "C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.8"
        $cudaExists = Test-Path $cudaPath
        $nvccExists = Get-Command nvcc -ErrorAction SilentlyContinue
        
        if ($cudaExists -and $nvccExists) {
            Write-Host "CUDA 11.8 is already installed and configured"
            Write-Host "CUDA Path: $cudaPath"
            Write-Host "NVCC Version: $((nvcc --version | Select-Object -First 1))"
        } else {
            Write-Host "Installing CUDA and cuDNN..."
            
            # Cache CUDA installer
            $cudaCache = "C:\cuda_cache"
            if (-not (Test-Path $cudaCache)) {
                New-Item -Path $cudaCache -ItemType Directory -Force
            }
            
            $cudaInstaller = Join-Path $cudaCache "cuda_installer.exe"
            if (-not (Test-Path $cudaInstaller)) {
                Write-Host "Downloading CUDA installer..."
                $cudaUrl = "https://developer.download.nvidia.com/compute/cuda/11.8.0/local_installers/cuda_11.8.0_522.06_windows.exe"
                Invoke-WebRequest -Uri $cudaUrl -OutFile $cudaInstaller
            } else {
                Write-Host "Using cached CUDA installer"
            }
            
            # Silent install CUDA
            Write-Host "Installing CUDA..."
            $process = Start-Process -FilePath $cudaInstaller -ArgumentList "-s" -PassThru -Wait
            if ($process.ExitCode -ne 0) {
                Write-Error "CUDA installation failed with exit code $($process.ExitCode)"
                exit 1
            }
        }
        
        # Ensure CUDA is in PATH
        $currentPath = [System.Environment]::GetEnvironmentVariable("Path", [System.EnvironmentVariableTarget]::Machine)
        if (-not $currentPath.Contains("CUDA")) {
            $env:PATH = "C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.8\bin;$env:PATH"
            Write-Host "Added CUDA to PATH"
        }
        
        # Verify CUDA setup
        Write-Host "Verifying CUDA setup..."
        nvcc --version
        if ($LASTEXITCODE -ne 0) {
            Write-Error "CUDA verification failed"
            exit 1
        }
        Write-Host "CUDA setup verified successfully"
      shell: pwsh

    - name: Check and Setup VS Build Tools
      run: |
        Write-Host "Checking Visual Studio Build Tools installation..."
        
        # Check if VS Build Tools are already installed
        $buildToolsPath = "C:\BuildTools"
        $vcvarsallPath = "C:\BuildTools\VC\Auxiliary\Build\vcvarsall.bat"
        $buildToolsExists = Test-Path $vcvarsallPath
        
        if ($buildToolsExists) {
            Write-Host "Visual Studio Build Tools are already installed"
            Write-Host "Build Tools Path: $buildToolsPath"
            
            # Verify installation
            cmd /c """$vcvarsallPath"" x64 && cl.exe 2>&1" | ForEach-Object { 
                if ($_ -match "Microsoft.*C/C\+\+ Compiler") {
                    Write-Host "Compiler version: $_"
                }
            }
        } else {
            Write-Host "Installing Visual Studio Build Tools..."
            
            # Cache VS Build Tools installer
            $vsCache = "C:\vs_cache"
            if (-not (Test-Path $vsCache)) {
                New-Item -Path $vsCache -ItemType Directory -Force
            }
            
            $vsInstaller = Join-Path $vsCache "vs_buildtools.exe"
            if (-not (Test-Path $vsInstaller)) {
                Write-Host "Downloading VS Build Tools installer..."
                $vsUrl = "https://aka.ms/vs/17/release/vs_buildtools.exe"
                Invoke-WebRequest -Uri $vsUrl -OutFile $vsInstaller
            } else {
                Write-Host "Using cached VS Build Tools installer"
            }
            
            # Install VS Build Tools
            Write-Host "Installing VS Build Tools..."
            $process = Start-Process -Wait -FilePath $vsInstaller -ArgumentList `
                "--quiet", "--wait", "--norestart", "--nocache", `
                "--installPath", $buildToolsPath, `
                "--add", "Microsoft.VisualStudio.Component.VC.Tools.x86.x64", `
                "--add", "Microsoft.VisualStudio.Component.Windows10SDK.19041" `
                -PassThru
                
            if ($process.ExitCode -ne 0) {
                Write-Error "VS Build Tools installation failed with exit code $($process.ExitCode)"
                exit 1
            }
        }
        
        # Verify Build Tools setup
        Write-Host "Verifying VS Build Tools setup..."
        if (-not (Test-Path $vcvarsallPath)) {
            Write-Error "VS Build Tools verification failed - vcvarsall.bat not found"
            exit 1
        }
        Write-Host "VS Build Tools setup verified successfully"
      shell: pwsh

    - name: Cache Ollama Model
      id: cache-ollama
      uses: actions/cache@v3
      with:
        path: |
          ~/.ollama/models
          OllamaSetup.exe
        key: ollama-codellama-3b-${{ runner.os }}
        restore-keys: |
          ollama-codellama-3b-

    - name: Setup Ollama
      run: |
        Write-Host "Setting up Ollama..."
        $maxWaitMinutes = 15  # Increased timeout to 15 minutes for slower networks
        $setupTimeout = (Get-Date).AddMinutes($maxWaitMinutes)
        Write-Host "Setup will timeout at: $($setupTimeout.ToString('HH:mm:ss'))"
        
        # Download Ollama if not cached
        if (-not (Test-Path "OllamaSetup.exe")) {
            Write-Host "Downloading Ollama..."
            $ollamaUrl = "https://ollama.ai/download/OllamaSetup.exe"
            try {
                $wc = New-Object System.Net.WebClient
                $wc.DownloadFile($ollamaUrl, "OllamaSetup.exe")
            } catch {
                Write-Error "Failed to download Ollama: $_"
                exit 1
            }
        } else {
            Write-Host "Using cached Ollama installer"
        }
        
        # Install Ollama with timeout
        Write-Host "Installing Ollama..."
        $process = Start-Process -FilePath .\OllamaSetup.exe -ArgumentList "/S" -PassThru
        $timeoutSeconds = 300
        if (-not $process.WaitForExit($timeoutSeconds * 1000)) {
            Write-Error "Ollama installation timed out after $timeoutSeconds seconds"
            Stop-Process -Id $process.Id -Force
            exit 1
        }
        if ($process.ExitCode -ne 0) {
            Write-Error "Ollama installation failed with exit code $($process.ExitCode)"
            exit 1
        }
        
        # Start and verify Ollama service
        Write-Host "Starting Ollama service..."
        Start-Service -Name Ollama
        $retryCount = 0
        $maxRetries = 6
        $serviceStarted = $false
        
        while ($retryCount -lt $maxRetries) {
            $service = Get-Service -Name Ollama -ErrorAction SilentlyContinue
            if ($service.Status -eq 'Running') {
                $serviceStarted = $true
                break
            }
            Write-Host "Waiting for Ollama service to start... Attempt $($retryCount + 1) of $maxRetries"
            Start-Sleep -Seconds 10
            $retryCount++
        }
        
        if (-not $serviceStarted) {
            Write-Error "Failed to start Ollama service after $maxRetries attempts"
            exit 1
        }
        
        # Create Ollama models directory if it doesn't exist
        $ollamaModelsDir = "$env:USERPROFILE\.ollama\models"
        if (-not (Test-Path $ollamaModelsDir)) {
            New-Item -Path $ollamaModelsDir -ItemType Directory -Force
        }

        # Check if model is already in cache
        $modelFiles = Get-ChildItem -Path $ollamaModelsDir -Filter "codellama*"
        if ($modelFiles.Count -eq 0) {
            Write-Host "Pulling smaller CodeLlama model (3B variant)..."
            $startTime = Get-Date
            
            # Start download with progress monitoring
            $job = Start-Job -ScriptBlock {
                $processInfo = New-Object System.Diagnostics.ProcessStartInfo
                $processInfo.FileName = "ollama"
                $processInfo.Arguments = "pull codellama:3b"
                $processInfo.RedirectStandardOutput = $true
                $processInfo.RedirectStandardError = $true
                $processInfo.UseShellExecute = $false
                
                $process = New-Object System.Diagnostics.Process
                $process.StartInfo = $processInfo
                $process.Start() | Out-Null
                
                while (-not $process.StandardOutput.EndOfStream) {
                    $line = $process.StandardOutput.ReadLine()
                    if ($line -match "(\d+\.\d+)%") {
                        $progress = [math]::Round([double]$matches[1], 2)
                        $elapsed = [math]::Round(((Get-Date) - $using:startTime).TotalMinutes, 1)
                        Write-Output "Progress: $progress% (${elapsed} minutes elapsed)"
                    }
                }
                $process.WaitForExit()
                return $process.ExitCode
            }
            
            # Monitor progress with timeout
            while (-not $job.HasMoreData -and (Get-Date) -lt $setupTimeout) {
                $output = Receive-Job -Job $job
                if ($output) {
                    Write-Host $output
                }
                
                # Show remaining time
                $remainingMinutes = [math]::Round(($setupTimeout - (Get-Date)).TotalMinutes, 1)
                if ($remainingMinutes -gt 0) {
                    Write-Host "Time remaining before timeout: $remainingMinutes minutes"
                }
                
                Start-Sleep -Seconds 30  # Update status every 30 seconds
            }
            
            # Get final status
            $exitCode = Receive-Job -Job $job -Wait
            Remove-Job -Job $job
            
            if ($exitCode -ne 0) {
                Write-Error "Model download failed with exit code $exitCode"
                exit 1
            }
            
            $totalTime = [math]::Round(((Get-Date) - $startTime).TotalMinutes, 1)
            Write-Host "Download completed in $totalTime minutes"
            
            if ($pullProcess.ExitCode -ne 0) {
                Write-Error "Model pull failed with exit code $($pullProcess.ExitCode)"
                Get-Content "ollama_pull.log"
                exit 1
            }
        } else {
            Write-Host "Using cached CodeLlama model"
        }
        
        # Verify Ollama is working
        Write-Host "Verifying Ollama installation..."
        $testResult = ollama list
        if ($LASTEXITCODE -ne 0 -or -not ($testResult -match "codellama")) {
            Write-Error "Ollama verification failed. Model not found in list: $testResult"
            exit 1
        }
        
        Write-Host "Ollama setup completed successfully"
      shell: pwsh
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install torch==2.1.0 transformers==4.35.0 accelerate==0.24.0 sentencepiece==0.1.99 protobuf==4.24.4
        pip install -r src/requirements.txt

    - name: Configure DNS resolution
      run: |
        Write-Host "Starting enhanced DNS configuration..."
        
        # Remove existing DNS configurations
        Get-DnsClientNrptRule | Remove-DnsClientNrptRule -Force
        Write-Host "Cleared existing DNS rules"
        
        # Configure specific DNS rules for different TR domains
        $rules = @(
            @{
                Namespace = ".thomsonreuters.com"
                Servers = @("10.173.12.233", "10.173.12.234")
            },
            @{
                Namespace = ".int.thomsonreuters.com"
                Servers = @("10.173.12.233", "10.173.12.234")
            },
            @{
                Namespace = ".gcs.int.thomsonreuters.com"
                Servers = @("10.173.12.233", "10.173.12.234")
            }
        )
        
        foreach ($rule in $rules) {
            try {
                Add-DnsClientNrptRule -Namespace $rule.Namespace -NameServers $rule.Servers -ErrorAction Stop
                Write-Host "Added DNS rule for $($rule.Namespace)"
            } catch {
                Write-Host "Warning: Failed to add rule for $($rule.Namespace): $_"
            }
        }
        
        # Configure network adapters
        $adapters = Get-NetAdapter | Where-Object {$_.Status -eq "Up"}
        foreach ($adapter in $adapters) {
            try {
                # Set primary DNS servers
                Set-DnsClientServerAddress -InterfaceIndex $adapter.InterfaceIndex -ServerAddresses @("10.173.12.233", "10.173.12.234", "8.8.8.8", "8.8.4.4") -ErrorAction Stop
                Write-Host "Configured DNS servers for adapter: $($adapter.Name)"
            } catch {
                Write-Host "Warning: Failed to configure DNS for adapter $($adapter.Name): $_"
            }
        }
        
        Write-Host "Flushing DNS cache..."
        ipconfig /flushdns
        
        # Add hosts file entry as fallback
        $hostEntry = "10.173.12.233 aiopenarena.gcs.int.thomsonreuters.com"
        Add-Content -Path "$env:windir\System32\drivers\etc\hosts" -Value $hostEntry -ErrorAction Continue
        Write-Host "Added hosts file entry as fallback"
        
        Write-Host "Verifying DNS configuration..."
        Get-DnsClientServerAddress | Where-Object {$_.InterfaceAlias -notlike "*Loopback*"} | Format-Table -AutoSize
        Get-DnsClientNrptRule | Format-List Namespace, NameServers
        
        Write-Host "Testing domain resolution..."
        $testDomains = @(
            "aiopenarena.gcs.int.thomsonreuters.com",
            "gcs.int.thomsonreuters.com",
            "int.thomsonreuters.com"
        )
        
        foreach ($domain in $testDomains) {
            Write-Host "`nTesting resolution for: $domain"
            try {
                $result = Resolve-DnsName -Name $domain -Type A -Server "10.173.12.233" -ErrorAction Stop
                Write-Host "Successfully resolved using TR DNS: $($result.IPAddress)"
            } catch {
                Write-Host "Failed with TR DNS: $_"
                try {
                    $result = Resolve-DnsName -Name $domain -Type A -Server "8.8.8.8" -ErrorAction Stop
                    Write-Host "Successfully resolved using Google DNS: $($result.IPAddress)"
                } catch {
                    Write-Host "Failed with Google DNS: $_"
                }
            }
        }
        
        # Final validation
        Write-Host "`nFinal connection test..."
        Test-NetConnection -ComputerName aiopenarena.gcs.int.thomsonreuters.com -Port 443 -WarningAction SilentlyContinue
        
    - name: Clean old reports
      run: |
        if (Test-Path "src/AI Reports") {
            Remove-Item -Path "src/AI Reports/*" -Force -Recurse
            Write-Host "Cleaned AI Reports directory"
        }

    - name: Run AI code review
      run: |
        # Enable debug logging
        $env:LOG_LEVEL = "DEBUG"
        # Set DNS timeout
        $env:DNS_TIMEOUT = "30"
        # Run the analysis with fallback mode enabled
        python src/main.py
        
    - name: Upload Analysis Reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ai-code-review-reports
        path: src/AI Reports/
        if-no-files-found: error
