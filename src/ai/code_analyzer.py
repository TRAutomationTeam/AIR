import requests
import yaml
import os
import json
from typing import Dict, List, Any
import logging
import re
import getpass

# Dynamically set Ollama path for current user

# Open Arena API config

OPEN_ARENA_API_URL = "https://aiopenarena.gcs.int.thomsonreuters.com/v1/inference"
OPEN_ARENA_API_KEY = "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlJERTBPVEF3UVVVMk16Z3hPRUpGTkVSRk5qUkRNakkzUVVFek1qZEZOVEJCUkRVMlJrTTRSZyJ9.eyJodHRwczovL3RyLmNvbS9mZWRlcmF0ZWRfdXNlcl9pZCI6IkMyOTE4MjUiLCJodHRwczovL3RyLmNvbS9mZWRlcmF0ZWRfcHJvdmlkZXJfaWQiOiJUUlNTTyIsImh0dHBzOi8vdHIuY29tL2xpbmtlZF9kYXRhIjpbeyJzdWIiOiJvaWRjfHNzby1hdXRofFRSU1NPfGMyOTE4MjUifV0sImh0dHBzOi8vdHIuY29tL2V1aWQiOiIxNjY2YzdlMC0yYWJiLTQ3YzgtYWFlYi03ZTAxZGJhMmFmMDYiLCJodHRwczovL3RyLmNvbS9hc3NldElEIjoiYTIwODE5OSIsImlzcyI6Imh0dHBzOi8vYXV0aC50aG9tc29ucmV1dGVycy5jb20vIiwic3ViIjoiYXV0aDB8NjU3OTZiZmU2NGI3OWEyY2RjZDRlZjBhIiwiYXVkIjpbIjQ5ZDcwYTU4LTk1MDktNDhhMi1hZTEyLTRmNmUwMGNlYjI3MCIsImh0dHBzOi8vbWFpbi5jaWFtLnRob21zb25yZXV0ZXJzLmNvbS91c2VyaW5mbyJdLCJpYXQiOjE3NTcwNjQyNTksImV4cCI6MTc1NzE1MDY1OSwic2NvcGUiOiJvcGVuaWQgcHJvZmlsZSBlbWFpbCIsImF6cCI6InRnVVZad1hBcVpXV0J5dXM5UVNQaTF5TnlvTjJsZmxJIn0.LYSIdmaSmJLgO2454RuN71dCTzeeizULt5t1T3DG6rCzbe4AzUtD5JAz0kvZSjchqJzU6e1pvOef0pV6IhSptkzzMf0XOBTqx8QQIaSacoSt_Mzt7DLCA8Byi_dNy5-Oy5n9NU18cDyuxDjAczSJFLO7HF35ewKi_fOVOBJgfo8tkeUeNNCumkI95ltGr2ySQ_GyLJpcJPYx7HIdj_-hazauYYxVy5NODxekHB7i4TU-OwYoHhdd_I_LVxmklUS3-IezbZ1uoFf6vWg6JyyU2s52was4UuoLLVe0sRRF_069P44A1zyghoDRX46P4AF2D6SyY7u4bQ1NLH3_cXKv3w"


class AICodeAnalyzer:
    def __init__(self, config: dict = None, metrics: dict = None):
        self.config = config or {}
        self.metrics = metrics or {}
        
    def analyze_workflow_results(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """Use local TinyLlama (via Ollama) for enhanced analysis and AI suggestions"""
        violations = analysis_results.get('rules_violations', [])
        if not violations:
            violations = analysis_results.get('original_analysis', {}).get('rules_violations', [])
        violations = [v for v in violations if v.get('Severity') in ('Warning', 'Error')]

        prompt_lines = [
            "You are an expert UiPath code reviewer. Here are the warnings and errors found in my UiPath workflows:",
            ""
        ]
        for v in violations:
            rule_id = v.get('RuleId', 'Unknown')
            rule_name = v.get('RuleName', '')
            severity = v.get('Severity', '')
            recommendation = v.get('Recommendation', '')
            file = v.get('File', v.get('FilePath', ''))
            prompt_lines.append(f"- [{severity}] {rule_id} ({rule_name}) in {file}: {recommendation}")
        prompt_lines.append("")
        prompt_lines.append("For each issue above, provide a specific, actionable suggestion to resolve it. Format your response as a numbered list, mapping each suggestion to the corresponding issue.")
        detailed_prompt = "\n".join(prompt_lines)

        # Call Open Arena API for AI suggestions
        try:
            payload = {
                "workflow_id": "80f448d2-fd59-440f-ba24-ebc3014e1fdf",
                "query": detailed_prompt,
                "is_persistence_allowed": False
            }
            headers = {
                "Authorization": f"Bearer {OPEN_ARENA_API_KEY}",
                "Content-Type": "application/json"
            }
            logging.info(f"[TR Arena API] Endpoint: {OPEN_ARENA_API_URL}")
            logging.info(f"[TR Arena API] Payload: {json.dumps(payload)}")
            response = requests.post(OPEN_ARENA_API_URL, headers=headers, json=payload, timeout=60)
            logging.info(f"[TR Arena API] Response status: {response.status_code}")
            if response.status_code == 200:
                data = response.json()
                logging.info(f"[TR Arena API] Response data: {json.dumps(data)}")
                answer = data.get("answer", "")
                suggestions = [line.strip() for line in answer.split('\n') if line.strip()]
                return {
                    'original_analysis': analysis_results,
                    'ai_insights': suggestions,
                    'recommendations': suggestions,
                    'quality_score': 0,
                    'go_no_go_decision': 'REVIEW_REQUIRED',
                    'confidence': 0,
                    'summary': 'AI suggestions generated by Open Arena',
                    'critical_issues': []
                }
            else:
                logging.error(f"[TR Arena API] Call failed: {response.text}")
                return self._fallback_analysis(analysis_results)
        except Exception as e:
            logging.error(f"[TR Arena API] Exception: {str(e)}")
            return self._fallback_analysis(analysis_results)

    def _process_ai_results(self, ai_results: Dict, original_results: Dict) -> Dict[str, Any]:
        """Process AI analysis results and combine with original analysis"""
        insights = []
        recommendations = []
        improvements = []
        quality_score = 0
        decision = 'REVIEW_REQUIRED'
        confidence = 0
        summary = ''
        critical_issues = []

        result = ai_results.get('result', {})
        answer = result.get('answer', {})
        model_data = answer.get(self.model_name, {}) if self.model_name in answer else answer

        def split_suggestions(text):
            if not isinstance(text, str):
                return text
            items = re.split(r'\n\s*\d+\.\s*', text)
            items = [i.strip() for i in items if i.strip()]
            if len(items) > 1:
                return items
            return [line.strip() for line in text.split('\n') if line.strip()]

        if isinstance(model_data, dict):
            insights = model_data.get('insights', [])
            recommendations = model_data.get('recommendations', [])
            improvements = model_data.get('improvements', [])
            quality_score = model_data.get('quality_score', 0)
            decision = model_data.get('decision', 'REVIEW_REQUIRED')
            confidence = model_data.get('confidence', 0)
            summary = model_data.get('summary', '')
            critical_issues = model_data.get('critical_issues', [])
            
            if isinstance(insights, str):
                insights = split_suggestions(insights)
            if isinstance(recommendations, str):
                recommendations = split_suggestions(recommendations)
            if isinstance(improvements, str):
                improvements = split_suggestions(improvements)
        elif isinstance(model_data, str):
            insights = split_suggestions(model_data)

        if not insights:
            insights = ai_results.get('insights', [])
            if isinstance(insights, str):
                insights = split_suggestions(insights)
        if not recommendations:
            recommendations = ai_results.get('recommendations', [])
            if isinstance(recommendations, str):
                recommendations = split_suggestions(recommendations)
        if not improvements:
            improvements = ai_results.get('improvements', [])
            if isinstance(improvements, str):
                improvements = split_suggestions(improvements)

        return {
            'original_analysis': original_results,
            'ai_insights': insights,
            'recommendations': recommendations,
            'quality_score': quality_score,
            'go_no_go_decision': decision,
            'confidence': confidence,
            'summary': summary,
            'critical_issues': critical_issues
        }

    def _fallback_analysis(self, analysis_results: Dict) -> Dict:
        """Return local analysis results when AI analysis fails"""
        logging.info("Using fallback analysis (local results only)")
        return {
            'original_analysis': analysis_results,
            'ai_insights': [],
            'recommendations': [],
            'quality_score': 0,
            'go_no_go_decision': 'REVIEW_REQUIRED',
            'confidence': 0,
            'summary': 'Analysis based on local rules only',
            'critical_issues': []
        }
